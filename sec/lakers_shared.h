// clang-format off

/*
 * ================================================================================================
 *  WARNING: This file is automatically generated by cbindgen. Manual edits are likely to be lost.
 * ================================================================================================
 */

#ifndef LAKERS_SHARED_H
#define LAKERS_SHARED_H

/* Manually implemented to work around https://github.com/mozilla/cbindgen/issues/1018 */

#if defined(_LARGE_BUFFERS)
#define _MAX_MESSAGE_SIZE_LEN_1024
#define _MAX_KDF_CONTENT_LEN_1024
#define _MAX_BUFFER_LEN_1024
#define _MAX_CONNID_ENCODED_LEN_24
#define _MAX_EAD_LEN_1024
#endif

#if defined(_MAX_MESSAGE_SIZE_LEN_1024)
#define MAX_MESSAGE_SIZE_LEN 1024
#elif defined(_MAX_MESSAGE_SIZE_LEN_512)
#define MAX_MESSAGE_SIZE_LEN 512
#elif defined(_MAX_MESSAGE_SIZE_LEN_448)
#define MAX_MESSAGE_SIZE_LEN 448
#elif defined(_MAX_MESSAGE_SIZE_LEN_384)
#define MAX_MESSAGE_SIZE_LEN 384
#elif defined(_MAX_MESSAGE_SIZE_LEN_320)
#define MAX_MESSAGE_SIZE_LEN 320
#elif defined(_MAX_MESSAGE_SIZE_LEN_256)
#define MAX_MESSAGE_SIZE_LEN 256
#else
#define MAX_MESSAGE_SIZE_LEN 128 + 64
#endif

#if defined(_MAX_KDF_CONTENT_LEN_1024)
#define MAX_KDF_CONTEXT_LEN 1024
#elif defined(_MAX_KDF_CONTENT_LEN_512)
#define MAX_KDF_CONTEXT_LEN 512
#elif defined(_MAX_KDF_CONTENT_LEN_448)
#define MAX_KDF_CONTEXT_LEN 448
#elif defined(_MAX_KDF_CONTENT_LEN_384)
#define MAX_KDF_CONTEXT_LEN 384
#elif defined(_MAX_KDF_CONTENT_LEN_320)
#define MAX_KDF_CONTEXT_LEN 320
#else
#define MAX_KDF_CONTEXT_LEN 256
#endif

#if defined(_MAX_BUFFER_LEN_1024)
#define MAX_BUFFER_LEN 1024
#elif defined(_MAX_BUFFER_LEN_512)
#define MAX_BUFFER_LEN 512
#elif defined(_MAX_BUFFER_LEN_448)
#define MAX_BUFFER_LEN 448
#elif defined(_MAX_BUFFER_LEN_384)
#define MAX_BUFFER_LEN 384
#else
#define MAX_BUFFER_LEN 256 + 64
#endif

#if defined(_MAX_EAD_LEN_1024)
#define MAX_EAD_LEN 1024
#elif defined(_MAX_EAD_LEN_768)
#define MAX_EAD_LEN 768
#elif defined(_MAX_EAD_LEN_512)
#define MAX_EAD_LEN 512
#elif defined(_MAX_EAD_LEN_384)
#define MAX_EAD_LEN 384
#elif defined(_MAX_EAD_LEN_256)
#define MAX_EAD_LEN 256
#elif defined(_MAX_EAD_LEN_192)
#define MAX_EAD_LEN 192
#elif defined(_MAX_EAD_LEN_128)
#define MAX_EAD_LEN 128
#else
#define MAX_EAD_LEN 64
#endif

#if defined(_MAX_CONNID_ENCODED_LEN_24)
#define MAX_CONNID_ENCODED_LEN 24
#else
#define MAX_CONNID_ENCODED_LEN 8
#endif


#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

#define ID_CRED_LEN 4

#define SUITES_LEN 9

#define SUPPORTED_SUITES_LEN 1

#define EDHOC_METHOD 3

#define P256_ELEM_LEN 32

#define SHA256_DIGEST_LEN 32

#define AES_CCM_KEY_LEN 16

#define AES_CCM_IV_LEN 13

#define AES_CCM_TAG_LEN 8

#define MAC_LENGTH 8

#define MAC_LENGTH_2 MAC_LENGTH

#define MAC_LENGTH_3 MAC_LENGTH_2

#define ENCODED_VOUCHER_LEN (1 + MAC_LENGTH)

#define MAX_EAD_ITEMS 4

#define MAX_KDF_LABEL_LEN 15

#define CBOR_BYTE_STRING 88

#define CBOR_TEXT_STRING 120

#define CBOR_UINT_1BYTE 24

#define CBOR_NEG_INT_1BYTE_START 32

#define CBOR_NEG_INT_1BYTE_END 55

#define CBOR_UINT_1BYTE_START 0

#define CBOR_UINT_1BYTE_END 23

#define CBOR_MAJOR_TEXT_STRING 96

#define CBOR_MAJOR_BYTE_STRING 64

#define CBOR_MAJOR_BYTE_STRING_MAX 87

#define CBOR_MAJOR_ARRAY 128

#define CBOR_MAJOR_ARRAY_MAX 151

#define CBOR_MAJOR_MAP 160

#define MAX_INFO_LEN ((((((2 + SHA256_DIGEST_LEN) + 1) + MAX_KDF_LABEL_LEN) + 1) + MAX_KDF_CONTEXT_LEN) + 1)

#define KCCS_LABEL 14

#define KCSS_LABEL KCCS_LABEL

#define KID_LABEL 4

#define ENC_STRUCTURE_LEN ((8 + 5) + SHA256_DIGEST_LEN)

#define MAX_SUITES_LEN 9

/**
 * An enum describing options how to send credentials.
 */
typedef enum CredentialTransfer {
  /**
   * This sends a short reference (key ID) of the credential.
   *
   * In order to complete the protocol, the peer needs to either know the full credential, or
   * load it from an external source, or extract it from (possibly protected) EAD data such as
   * a CWT.
   */
  ByReference,
  /**
   * This sends a credential by value.
   *
   * The peer can complete the protocol without additional information, although in most cases
   * the peer will still need to inspect the value.
   */
  ByValue,
} CredentialTransfer;

typedef enum CredentialType {
  CCS,
  CCS_PSK,
} CredentialType;

/**
 * A fixed-size (but parameterized) buffer for EDHOC messages.
 *
 * Trying to have an API as similar as possible to `heapless::Vec`,
 * so that in the future it can be hot-swappable by the application.
 */
typedef struct EdhocBuffer_MAX_MESSAGE_SIZE_LEN {
  uint8_t content[MAX_MESSAGE_SIZE_LEN];
  uintptr_t len;
} EdhocBuffer_MAX_MESSAGE_SIZE_LEN;

/**
 * An [`EdhocBuffer`] used for messages.
 */
typedef struct EdhocBuffer_MAX_MESSAGE_SIZE_LEN EdhocMessageBuffer;

typedef uint8_t BytesMac[MAC_LENGTH];

typedef uint8_t BytesMac2[MAC_LENGTH_2];

/**
 * A fixed-size (but parameterized) buffer for EDHOC messages.
 *
 * Trying to have an API as similar as possible to `heapless::Vec`,
 * so that in the future it can be hot-swappable by the application.
 */
typedef struct EdhocBuffer_MAX_EAD_LEN {
  uint8_t content[MAX_EAD_LEN];
  uintptr_t len;
} EdhocBuffer_MAX_EAD_LEN;

typedef struct EdhocBuffer_MAX_EAD_LEN EADBuffer;

/**
 * A fixed-size (but parameterized) buffer for EDHOC messages.
 *
 * Trying to have an API as similar as possible to `heapless::Vec`,
 * so that in the future it can be hot-swappable by the application.
 */
typedef struct EdhocBuffer_16 {
  uint8_t content[16];
  uintptr_t len;
} EdhocBuffer_16;

typedef struct EdhocBuffer_16 BufferKid;

/**
 * A fixed-size (but parameterized) buffer for EDHOC messages.
 *
 * Trying to have an API as similar as possible to `heapless::Vec`,
 * so that in the future it can be hot-swappable by the application.
 */
typedef struct EdhocBuffer_192 {
  uint8_t content[192];
  uintptr_t len;
} EdhocBuffer_192;

typedef struct EdhocBuffer_192 BufferCred;

typedef struct EdhocBuffer_192 BufferIdCred;

typedef uint8_t BytesKeyAES128[16];

typedef uint8_t BytesKeyEC2[32];

typedef enum CredentialKey_Tag {
  Symmetric,
  EC2Compact,
} CredentialKey_Tag;

typedef struct CredentialKey {
  CredentialKey_Tag tag;
  union {
    struct {
      BytesKeyAES128 symmetric;
    };
    struct {
      BytesKeyEC2 ec2_compact;
    };
  };
} CredentialKey;

/**
 * A value of ID_CRED_x: a credential identifier.
 *
 * Possible values include key IDs, credentials by value and others.
 *
 * ```rust
 * # use hexlit::hex;
 * # use lakers_shared::IdCred;
 * let short_kid = IdCred::from_encoded_value(&hex!("17")).unwrap(); // 23
 * assert_eq!(short_kid.as_full_value(), &hex!("a1044117")); // {4: h'17'}
 * let long_kid = IdCred::from_encoded_value(&hex!("43616263")).unwrap(); // 'abc'
 * assert_eq!(long_kid.as_full_value(), &hex!("a10443616263")); // {4: 'abc'}
 * ```
 */
typedef struct IdCred {
  /**
   * The value is always stored in the ID_CRED_x form as a serialized one-element dictionary;
   * while this technically wastes two bytes, it has the convenient property of having the full
   * value available as a slice.
   */
  BufferIdCred bytes;
} IdCred;

/**
 * A fixed-size (but parameterized) buffer for EDHOC messages.
 *
 * Trying to have an API as similar as possible to `heapless::Vec`,
 * so that in the future it can be hot-swappable by the application.
 */
typedef struct EdhocBuffer_MAX_SUITES_LEN {
  uint8_t content[MAX_SUITES_LEN];
  uintptr_t len;
} EdhocBuffer_MAX_SUITES_LEN;

typedef uint8_t BytesP256ElemLen[P256_ELEM_LEN];

typedef struct InitiatorStart {
  struct EdhocBuffer_MAX_SUITES_LEN suites_i;
  uint8_t method;
  BytesP256ElemLen x;
  BytesP256ElemLen g_x;
} InitiatorStart;

typedef uint8_t BytesHashLen[SHA256_DIGEST_LEN];

typedef struct WaitM2 {
  BytesP256ElemLen x;
  BytesHashLen h_message_1;
} WaitM2;

typedef struct Completed {
  BytesHashLen prk_out;
  BytesHashLen prk_exporter;
} Completed;

typedef struct ProcessedM2 {
  BytesHashLen prk_3e2m;
  BytesHashLen prk_4e3m;
  BytesHashLen th_3;
} ProcessedM2;

typedef struct WaitM4 {
  BytesHashLen prk_4e3m;
  BytesHashLen th_4;
  BytesHashLen prk_out;
  BytesHashLen prk_exporter;
} WaitM4;

#endif  /* LAKERS_SHARED_H */

// clang-format on
